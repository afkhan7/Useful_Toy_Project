<!DOCTYPE html>
<html>
<head>
  <title>Realtime communication with WebRTC</title>
  <!-- <link rel="stylesheet" href="css/main.css" /> -->
  <script src="libc.js"></script> <!-- 커스텀 자바스크립트 함수 -->
  <!-- <script src="webRTC_client.js" defer></script> -->
</head>
<style>
  .my-video{
    width:720px;
    height:360px;
    border: 1px solid black;
  }

</style>
<body>
  <h1>Realtime communication with WebRTC</h1>
  <div id="videos">
    <video class='my-video' id="localVideo" autoplay ></video>
  </div>
  <div id="videos">
    <video class='my-video' id="remoteVideo" autoplay ></video>
  </div>
  <p id="wscount"></p>
  <form>
    <input type="text" id="wsid">
    <input type="button" id="ws_button" value="연결 ws" onclick="try_ws_connect();" >
  </form>
  <script>
    
    // 스트림을 전달 받을 비디오 요소
    var localVideo = document.querySelector('#localVideo');
    var wscount = document.querySelector('p#wscount');
    var ws_button = document.querySelector('#ws_button');

    const Constraints = { video: true, audio: false  };
    let localStream = null;
    const remoteStream = new MediaStream(); //먼저 빈 인스턴스 생성

    async function getUserMediaStream(Constraints){
      console.log('0. get localstream');
      // 1. 호출 후 브라우저는 사용자에게 카메라에 액세스 할 수있는 권한을 요청
      await navigator.mediaDevices.getUserMedia(Constraints)
        .then(stream =>{ // 2. stream을 가져옴
          localVideo.srcObject = stream; // 3. srcObject속성을 통해 스트림 전달
          localStream = stream;
          console.log(stream);
        })
        .catch(error =>{ // 2. 실패 할경우 에러 메시지 출력
          console.log('navigator.getUserMedia error: ', error);
        });
    }

    // 시그널링을 위해 소켓 객체 생성
    async function try_ws_connect(){
      await getUserMediaStream(Constraints);
      const videoTracks = await localStream.getVideoTracks();
      if(videoTracks.length > 0){
        console.log(`using vidoe device : ${videoTracks[0].label}`)
      }
      var wsid_html = await document.getElementById("wsid").value;
      await console.log("1. ws 연결 시도, 입력한 wsid :: "+ wsid_html )
      const wsid = wsid_html;
      const wstype = 'webrtc'
      //const url = 'wss://192.168.31.77:3000' https://7907d87513dc.ngrok.io   
      const url = 'wss://7907d87513dc.ngrok.io'
      const wsk = new WebSocket(`${url}/wsid=${wsid}&wstype=${wstype}`); // 웹소켓 연결 및 소켓 객체 생성
      
      const configuration = {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]}// 피어연결 설정 방법 정의 및 ICE 서버 정보
      const peerConnection = new RTCPeerConnection(configuration); // RTCPeerConnection객체 생성

      localStream.getTracks().forEach(track => {
        console.log('local track!!')
        peerConnection.addTrack(track, localStream);
      });      
      var remoteVideo = document.querySelector('#remoteVideo');

      // 원격에서 전달되는 스트림 수신
      peerConnection.addEventListener('track', async (event) => {
        if(remoteVideo.srcObject !== event.streams[0]){
          remoteVideo.srcObject = event.streams[0];
          console.log('remote track !!')
        }
      });
      // 로컬의 ICE 후보를 수집 하기 위해 icecandidate를 이벤트로 등록
      peerConnection.addEventListener('icecandidate', e => {
        if (event.candidate) {
          console.log('icecandidate!!')
          wsk.send(JSON.stringify({optype : 'new-ice-candidate', icecandidate : event.candidate, 'wsid' : wsid})); // 발견된 ICE를 원격 피어로 전달
        }else{
          console.log('All ICE candidates have been sent');
        }
      });
      // 연결 완료 상황을 알기 위해 connectionstatechange 이벤트 등
      peerConnection.addEventListener('connectionstatechange', event => {
        if (event) {// Peers connected!
          console.log(`연결상태 :: ${peerConnection.connectionState}`)
          // 로컬 스트림을 원격으로 전달
        }
      });

      // 웹소켓 연결시
      wsk.onopen = function () {
        console.log('2. [웹소켓 연결 성공]서버와 웹 소켓 연결됨');
        wsk.send(JSON.stringify({'optype': 'check_ws_num' ,'wsid' : wsid})); 
      };
      wsk.onclose = function () {
        console.log('[웹소켓 연결 종료]서버와 웹 소켓 연결이 종료됨');
      };


    async function getOffer(peerConnection){
      console.log("3. 호출측 정보 준비 offer")
      const offer = await peerConnection.createOffer();   // 로컬에 대한 정보를 담은 객체 생성
      await peerConnection.setLocalDescription(offer);    // 이 객체를 로컬 설정에 등록
      return offer
    }

    async function treatOffer(peerConnection, offer){
      console.log("6. 전달 받은 offer 내용을 수신측의 원격 정보로 등록.")
      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));// 전달 받은 호출 측 메타 정보를 이용하여 세션 객체로 생성하고 원격 설정 내용에 등록
      const answer = await peerConnection.createAnswer(); // 수신 측 피어에 대한 정보를 담은 객체 생성
      await peerConnection.setLocalDescription(answer);  // 수신 측 피어 로컬 정보에 위 객체를 등록
      return answer
    }

    async function treatAnswer(peerConnection, answer){
      console.log("9. 전달 받은 answer 내용을 호출측의 원격 정보로 등록")
      const remoteDesc = await new RTCSessionDescription(answer); // 전달 받은 수신측 메타 정보로 세션 객체로 생성
      await peerConnection.setRemoteDescription(remoteDesc);  // 수신 측 세션 객체를 피어의 원격의 설정 내용에 등록
    }
    
    // 호출 쪽
    wsk.onmessage = function (event) { // 전달한 정보에 대한 응답을 처리하는 로직
      msgjson = JSON.parse(event.data);
      switch (msgjson.optype) {	
        case 'check_ws_num':
          getOffer(peerConnection)
          .then(offer =>{
            console.log("4. 호출측에 대한 정보를 수신측으로 전달");
            wsk.send(JSON.stringify({'optype': 'offer' ,'offer': offer, 'wsid' : wsid}));   // 웹소켓을 통해 호출 측 피어에 대한 메타 정보를 수신 측으로 전달
          }) 
          break;
        case 'offer': 
          console.log("5. offer 받음.")
          treatOffer(peerConnection, msgjson.offer)
          .then(answer =>{
            console.log("7. 호출 측으로 answer 전달 ");
            wsk.send(JSON.stringify({'optype': 'answer' ,'answer': answer, 'wsid' : wsid}));  // 호출 측에 응답으로 수신측 피어에 대한 메타 정보를 전달
          })
          break;
        case 'answer':
          console.log("8. answer 받음.")
          treatAnswer(peerConnection, msgjson.answer).then(()=>{
            console.log("10 . answer done! :: ");
          })
          break;
        case 'new-ice-candidate':
          console.log('11. new-ice-candidate!! 받음.')
          try {
            peerConnection.addIceCandidate(msgjson.icecandidate); // 수신 받은 ICE를 등록
            } catch (e) {
                console.error('Error adding received ice candidate', e);
            }
          break;
        case 'ws_count':
          wscount.innerHTML = "접속자 수 : " + msgjson.ws_count;
          break;
        default:
          console.log('optype error : ' + msgjson.optype)
        }
      };
    }
  </script>
</body>
</html>
