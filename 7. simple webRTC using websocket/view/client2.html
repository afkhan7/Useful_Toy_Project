<!DOCTYPE html>
<html>
<head>
  <title>Realtime communication with WebRTC</title>
  <!-- <link rel="stylesheet" href="css/main.css" /> -->
  <script src="libc.js"></script> <!-- 커스텀 자바스크립트 함수 -->
</head>
<body>
  <h1>Realtime communication with WebRTC</h1>
  <div id="videos">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>
  <p id="wscount"></p>
  <button type="button" onclick="try_connect();">연결</button>
  <script>
    
    const Constraints = {
      video: true,
    };

    // 스트림을 전달 받을 비디오 요소
    var localVideo = document.querySelector('#localVideo');
    var remoteVideo = document.querySelector('#remoteVideo');
    var wscount = document.querySelector('p#wscount');
    
    function try_connect(){
      getOffer(peerConnection)
      .then(offer =>{
        //console.log(offer);
        wsk.send(JSON.stringify({'optype': 'offer' ,'offer': offer}));   // 웹소켓을 통해 호출 측 피어에 대한 메타 정보를 수신 측으로 전달
      }) 
    }

    const localStream = getUserMedia(Constraints);

    function getUserMedia(Constraints){
      // 1. 호출 후 브라우저는 사용자에게 카메라에 액세스 할 수있는 권한을 요청
      navigator.mediaDevices.getUserMedia(Constraints)
        .then(stream =>{ // 2. stream을 가져옴
          localVideo.srcObject = stream; // 3. srcObject속성을 통해 스트림 전달
          return stream
        })
        .catch(error =>{ // 2. 실패 할경우 에러 메시지 출력
          console.log('navigator.getUserMedia error: ', error);
        });
    }

    // 시그널링을 위해 소켓 객체 생성
    const wsid = timestamp();
    const wstype = 'webrtc'
    const wsk = new WebSocket(`ws://localhost:8000/wsid=${wsid}&wstype=${wstype}`); // 웹소켓 연결 및 소켓 객체 생성
    // 웹소켓 연결시
    wsk.onopen = function () {
      console.log('[웹소켓 연결 성공]서버와 웹 소켓 연결됨');
    };

    async function getOffer(peerConnection){
      const offer = await peerConnection.createOffer();   // 로컬에 대한 정보를 담은 객체 생성
      await peerConnection.setLocalDescription(offer);    // 이 객체를 로컬 설정에 등록
      return offer
    }

    async function treatOffer(peerConnection, offer){
      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));// 전달 받은 호출 측 메타 정보를 이용하여 세션 객체로 생성하고 원격 설정 내용에 등록
      const answer = await peerConnection.createAnswer(); // 수신 측 피어에 대한 정보를 담은 객체 생성
      await peerConnection.setLocalDescription(answer);  // 수신 측 피어 로컬 정보에 위 객체를 등록
      return answer
    }

    async function treatAnswer(peerConnection, answer){
      const remoteDesc = await new RTCSessionDescription(answer); // 전달 받은 수신측 메타 정보로 세션 객체로 생성
      await peerConnection.setRemoteDescription(remoteDesc);  // 수신 측 세션 객체를 피어의 원격의 설정 내용에 등록
    }
    const configuration = {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]}// 피어연결 설정 방법 정의 및 ICE 서버 정보
    
    // 호출 쪽
    const peerConnection = new RTCPeerConnection(configuration); // RTCPeerConnection객체 생성
    wsk.onmessage = function (event) { // 전달한 정보에 대한 응답을 처리하는 로직
      msgjson = JSON.parse(event.data);
      switch (msgjson.optype) {	
        case 'offer': 
          treatOffer(peerConnection, msgjson.offer)
          .then(answer =>{
            //console.log(answer);
            wsk.send(JSON.stringify({'optype': 'answer' ,'answer': answer}));  // 호출 측에 응답으로 수신측 피어에 대한 메타 정보를 전달
          })
          break;
        case 'answer':
          treatAnswer(peerConnection, msgjson.answer).then(()=>{
            console.log("answer done!")
          })
          break;
        case 'new-ice-candidate':
          try {
                peerConnection.addIceCandidate(msgjson.iceCandidate); // 수신 받은 ICE를 등록
            } catch (e) {
                console.error('Error adding received ice candidate', e);
            }
          break;
        case 'ws_count':
          wscount.innerHTML = "접속자 수 : " + msgjson.ws_count;
          break;
        default:
          console.log('optype error : ' + msgjson.optype)
        }
    };

    const remoteStream = new MediaStream(); //먼저 빈 인스턴스 생성
    remoteVideo.srcObject = remoteStream;

    // 원격에서 전달되는 스트림 수신
    peerConnection.addEventListener('track', async (event) => {
        remoteStream.addTrack(event.track, remoteStream);
    });

    // 로컬의 ICE 후보를 수집 하기 위해 icecandidate를 이벤트로 등록
    peerConnection.addEventListener('icecandidate', event => {
        if (event.candidate) {
            console.log('icecandidate!!')
            wsk.send(JSON.stringify({optype : 'new-ice-candidate', icecandidate : event.candidate})); // 발견된 ICE를 원격 피어로 전달
        }
    });

    // 연결 완료 상황을 알기 위해 connectionstatechange 이벤트 등
    peerConnection.addEventListener('connectionstatechange', event => {
        if (peerConnection.connectionState === 'connected') {// Peers connected!
          console.log('WebRTC 연결 완료!!!')
          // 로컬 스트림을 원격으로 전달
          localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
          });
        }
    });

  </script>
</body>
</html>
